<html>
<head>
    <title>Reactive App, generated by EasyMda</title>
</head>
<body>
<div>
<h2>Intro</h2>
<p>
    This Activator Template is a yet another Reactive application based on: Spray, Akka and Slick with a few twists!
</p>
</div>
  <ul>
    <li>
    In the Slick persistence layer, a (almost) complete, very efficient (meaning: with a little as possible sql statements), ORM is implementen. 
    Currently this version supports most standard types,
    onetomany manytoone and onetoone relations.
    </li>
    <li>
    But most important ... the entire application is completely generated, with an Eclipse plugin. Not a single line of code was hand-coded!
    </li>
  </ul>
This so called EasyMda plugin is currently still work in progess, hence this Activator only demonstrates
the generated Scala based backend, but in the near future it can also generate a fully functional Google Dart frontend. <br>
By than, I also want to have the currently missing ORM pieces: manytomany relations (resulting in a join-table), 
object inheritance and support for blob and clob datatypes.<br>
Please visit: the <a href="https://code.google.com/p/easymda/" class="shortcut">Easymda</a> website for more information how this code
generator works. There you may find tutorials, some Youtube video's, and documentation that shows how easy it is to modify the (jet-engine)
templates, so that you can modify the generated code anyway you want.
<p>
<strong>Please let me know what parts of the code can be improved, so that I can update the corresponding template(s)</strong>
</p>

<h2>The Reactive App</h2>

This demo application is a typical Reactive based on the well known stack: Spray, Akka and Slick. I created the cartridge templates based
on numerous examples from previous activator projects.

<h2>What is being generated</h2>

<p>
Everything...!
</p>

In <strong>src/main/resources/models-sources.zip</strong> you can find all the java-based model, that were used to generate this
reactive application.<br>
For all the entities (all classes that implements IEntityType), the following classes are generated (using the model class Tsta as an example):
  <ul>
    <li>
    The corresponding Scala entity case class: <a href="#code/src-gen/flca/demo/entity/Tsta.scala"  class="shortcut">src-gen/flca/demo/entity/Tsta.scala</a><br>
    In this file also the <strong>FdTsta</strong> case class is generated. This is the 'fetch-depth' case class that will be desribed below.
    </li>
    <li>The dao base class <a href="#code/src-gen/flca/demo/entity/dao/TstaDaoBase.scala"  class="shortcut">src-gen/flca/demo/entity/dao/TstaDaoBase.scala</a>
    This class contains the <strong>TstaRow</strong> case class that is used to map the row, and all supporting code to perform
    this mapping.
    </li>
    <li>The dao class <a href="#code/src-gen/flca/demo/entity/dao/TstaDao.scala"  class="shortcut">src-gen/flca/demo/entity/dao/TstaDao.scala</a>
    This almost empty class extends from the base class above, and can be used to implement your own queries.
    </li>
    <li>The Akka actor class <a href="#code/src-gen/flca/demo/entity/actor/TstaDaoSrvActor.scala"  class="shortcut">src-gen/flca/demo/entity/actor/TstaDaoSrvActor.scala</a>
    This almost empty class extends from the base class above, and can be used to implement your own queries.
    </li>
    <li>The Scala trait <a href="#code/src-gen/flca/demo/entity/srv/TstaDaoSrv.scala"  class="shortcut">src-gen/flca/demo/entity/srv/TstaDaoSrv.scala</a>
    implemented by <a href="#code/src-gen/flca/demo/entity/srv/TstaDaoSrvImpl.scala"  class="shortcut">src-gen/flca/demo/entity/srv/TstaDaoSrvImpl.scala</a>
    that is used to call the dao class from above. 
    </li>
    <li>The Spray route class <a href="#code/src-gen/flca/demo/entity/route/TstaDaoRoute.scala"  class="shortcut">src-gen/flca/demo/entity/route/TstaDaoRoute.scala</a>
    that will handle the incoming http requests and active the actor from above. This class is only generated if the entity model class is annotated 
    with <strong>@RestService</strong>.
    </li>
    <li>
    Under <strong>src-gen-test</strong> you may find corresponding junit test classes, to test the dao, mapping etc.
    </li>
  </ul>
 For other model classes, like services (model class that implement IServiceType) or dto's (implement IDtoType) somewhat similar classes are generated,
 but without the dao layer.

<h2>Persistence layer, with Slick</h2>

Most of the time was spent in the ability to support complete ORM mapping, similar to Hibernate but than better. 
It is now indeed possible to retrieve with one service call a complete (deeply) nested object tree, 
and also perform a full update of an object tree. 
I try to this in such a way that it requires a little as  possible sql calls. 
And I also want to have full control over what exactly is fetched. 
<p>
For this reason, all entity classes have two (maybe cryptic) val properties: 
fd:Option[FdXxx], ohc:List[Long]
The "fd" is a shortcut for  FetchDepth. 
This option can be used to tell exactly what nested relations should be fetched or not. 
So rather than the @Eager vs @Lazy annotation that is set only once, this option gives the client control over this behaviour. 
By default the generated find command will not fetch any nested object, and the generated retrieve will fetch the complete tree, 
but the client this is free to change this in any way it wants.
</p>
<p>
The "ohc" is a shortcut for OldHashCode(s). This value is set when an object is retrieved, 
and it contains the hashcode of the corresponding row class, so it will be returned to the client. 
When the client later updates this object, with the saveXxx service call, the dao layer will compare the old hashcode 
with the new hashcode and will only perform an actual sql update if the hashcodes differ. And it does so for all nested objects. 
You may have noticed that the "ohc" is a List. That is because in addition to the 'main' hashcode, that is the hashcode of the 
corresponding row class, it may also contain hashcode(s) for all manytoone relations. These values are used to figure out a the 
client added and/or removed an element from a manytoone collection.
For retrieving an object tree different strategies can be used. One is to generate a (possible very complex) join query. 
This is difficult to generate and may result in transporting a lot of waste because many same column values will be transferred 
for each collection instance again. A naive  strategy is to reuse the retrieve commands of the nested objects. 
This is elegant and easy to generate but this may result in many individual sql select calls. I opted for another strategy. 
I try to execute just one sql statement for each nested class in the object tree, and merge the results afterwards. 
These sql statements for each class can run parallel (this is not done yet, see improvements),
so that the performance is in par with a complex join query, maybe faster because (much) less data needs to be transferred.
</p>
</body>
</html>